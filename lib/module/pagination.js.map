{"version":3,"sources":["pagination.ts"],"names":["ChatKittyError","ChatKittyPaginator","createInstance","request","page","Promise","resolve","reject","stompX","relayResource","destination","relay","parameters","onSuccess","resource","onError","error","items","_embedded","contentName","mapper","asyncMapper","map","item","mappedItems","concat","_relays","prev","next","constructor","prevRelay","nextRelay","hasPrevPage","hasNextPage","prevPage","getPage","nextPage","PageOutOfBoundsError"],"mappings":"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","sourcesContent":["import StompX, { StompXError, StompXPage } from './stompx';\n\nimport { ChatKittyError } from './error';\n\nexport class ChatKittyPaginator<I> {\n  static async createInstance<I>(\n    request: CreatePaginatorRequest<I>\n  ): Promise<ChatKittyPaginator<I>> {\n    const page = await new Promise<StompXPage>((resolve, reject) => {\n      request.stompX.relayResource<StompXPage>({\n        destination: request.relay,\n        parameters: request.parameters,\n        onSuccess: (resource) => resolve(resource),\n        onError: (error) => reject(error),\n      });\n    });\n\n    let items: I[] = [];\n\n    if (page._embedded) {\n      items = page._embedded[request.contentName] as I[];\n    }\n\n    const mapper = request.mapper;\n\n    const asyncMapper = request.asyncMapper;\n\n    if (mapper) {\n      items = items.map((item) => mapper(item));\n    } else if (asyncMapper) {\n      const mappedItems: I[] = [];\n\n      for (const item of items) {\n        mappedItems.concat(await asyncMapper(item));\n      }\n\n      items = mappedItems;\n    }\n\n    return new ChatKittyPaginator<I>(\n      items,\n      request.stompX,\n      request.contentName,\n      page._relays.prev,\n      page._relays.next,\n      request.parameters,\n      mapper,\n      asyncMapper\n    );\n  }\n\n  private constructor(\n    public items: I[],\n    private stompX: StompX,\n    private contentName: string,\n    private prevRelay?: string,\n    private nextRelay?: string,\n    private parameters?: Record<string, unknown>,\n    private mapper?: (item: I) => I,\n    private asyncMapper?: (item: I) => Promise<I>\n  ) {}\n\n  get hasPrevPage(): boolean {\n    return !!this.prevRelay;\n  }\n\n  get hasNextPage(): boolean {\n    return !!this.nextRelay;\n  }\n\n  async prevPage(): Promise<ChatKittyPaginator<I>> {\n    return this.getPage(this.prevRelay);\n  }\n\n  async nextPage(): Promise<ChatKittyPaginator<I>> {\n    return this.getPage(this.nextRelay);\n  }\n\n  private async getPage(relay?: string): Promise<ChatKittyPaginator<I>> {\n    const page = await new Promise<StompXPage>((resolve, reject) => {\n      if (relay) {\n        this.stompX.relayResource<StompXPage>({\n          destination: relay,\n          parameters: this.parameters,\n          onSuccess: (resource) => resolve(resource),\n          onError: (error) => reject(error),\n        });\n      } else {\n        reject(new PageOutOfBoundsError());\n      }\n    });\n\n    let items: I[] = [];\n\n    if (page._embedded) {\n      items = page._embedded[this.contentName] as I[];\n    }\n\n    const mapper = this.mapper;\n\n    const asyncMapper = this.asyncMapper;\n\n    if (mapper) {\n      items = items.map((item) => mapper(item));\n    } else if (asyncMapper) {\n      const mappedItems: I[] = [];\n\n      for (const item of items) {\n        mappedItems.concat(await asyncMapper(item));\n      }\n\n      items = mappedItems;\n    }\n\n    return new ChatKittyPaginator<I>(\n      items,\n      this.stompX,\n      this.contentName,\n      page._relays.prev,\n      page._relays.next,\n      this.parameters,\n      this.mapper,\n      this.asyncMapper\n    );\n  }\n}\n\nexport declare class CreatePaginatorRequest<I> {\n  stompX: StompX;\n  relay: string;\n  contentName: string;\n  parameters?: Record<string, unknown>;\n  mapper?: (item: I) => I;\n  asyncMapper?: (item: I) => Promise<I>;\n  onError?: (error: StompXError) => void;\n}\n\nexport class PageOutOfBoundsError extends ChatKittyError {\n  constructor() {\n    super(\n      'PageOutOfBoundsError',\n      \"You've requested a page that doesn't exists.\"\n    );\n  }\n}\n"]}